---
title: "It's not fair"
title: "Gerrymandering by whom"
author: "Bruce Mallory"
date: "12/2/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load("HelpersMG", "readr", "ggplot2", "lmer4", "rstanarm", "dplyr", "stringr", "e1071", "ggrepel", "moderndive", "broom")
options(dplyr.summarise.inform = FALSE)

#moderndive allows geom_parallel_slopes() ... see https://campus.datacamp.com/courses/intermediate-regression-in-r/parallel-slopes-1?ex=1
```
# ABSTRACT

# INTRODUCTION

# METHODS
## (1) Load and clean election data
### (1A) build rslts data.frame
```{r echo=FALSE, warning=FALSE, message=FALSE}
#wget("https://dataverse.harvard.edu/api/access/datafile/:persistentId?persistentId=doi:10.7910/DVN/IG0UN2/ELBYL3")
rslts <- read.table("ELBYL3", header = TRUE)

# Historical note.  In the data file, there was a column "special."  There were two sets of elections where special="TRUE."  Both is Texas.  One in 1996, the other 2006.  In the first the US District Court found that the redrawn districts were unconstitutional and ordered a special election to redo the primary election - then held a general election in December.  And again in 2006, the US Supreme Court found that numerous redrawn districts were unconstitutional and again ordered a new district map and a special election for the primaries with a December general election.  Since these special elections were "redoing" the primary elections in those districts, I've removed them from the data set, thus keeping only the general elections in the data set.  These were the only cases in the data file where there where special elections.  And because of this story of split aliegance of who was doing the redistricting, I've put TX in the "independent" group for 2000 redistricting.
rslts <- filter(rslts, special = TRUE)

# From the data set, I've kept seven columns for my analysis and filtered out for years 2002 and beyond
rslts <-
  subset(
    rslts,
    select = c(
      year,
      state_po,
      district,
      candidate,
      party,
      candidatevotes,
      totalvotes
    )
  )
rslts <- rslts %>%  rename(state = state_po)
rslts <- filter(rslts, year >= 2002)
rslts$percent <- round(100 * rslts$candidatevotes / rslts$totalvotes, 2)

# NOTE: in Minnesota, the democratic party is called "democratic-farmer-labor," so I've changed it's name in the data.frame to "democrat."  And same for the republican party "independent-republican"
rslts$party[rslts$party == "democratic-farmer-labor"] <- "democrat"
rslts$party[rslts$party == "independent-republican"] <- "republican"

# In preparation for collecting the uncontested elections, I checked to see whether or not I should include the "libertarian" party.  They ran candidates in 2,018 elections between 1990 and 2018.  But never got higher than 31% of the vote and their mean vote percentage was 3.4% (with a distribution of results that was heavily skewed right with "skewness" = 3.4).  As such I have not included the "libertarian" party as a major party, and have confined my analysis to Democrats and Republicans.
libs <- filter(rslts, party == "libertarian")
num_libertarian_canditates <- nrow(libs)
high_percent_libertarians <- max(libs$percent)
mean_percent_libertarians <- mean(libs$percent)
skew_percent_libertarians <- skewness(libs$percent)

# Remove all states that only have one representative to congress - in these states there is never a need for redistricting (WY, VT, SD, ND, MT, DE, AK)
rslts <- filter(rslts, !state %in% c("WY", "VT", "SD", "ND", "MT", "DE", "AK"))

# Include candidates who are either republican or democrat
rslts <- filter(rslts, party == "democrat" | party == "republican")


```
### (1B) build grouping variable
```{r echo=FALSE}
state_abbrs <- read.csv("states.csv")

one_district <- c("WY", "VT", "SD", "ND", "MT", "DE", "AK")
state_abbrs <- filter(state_abbrs, !Code %in% paste(one_district, "DC"))


repub_2010 <- c("AL", "FL", "GA", "IN", "LA", "MI", "NE", "NH", "NC", "OH", "OK", "PA", "SC", "TN", "UT", "VA", "WI")
dem_2010 <- c("AR", "IL", "MD", "MA", "RI", "WV")
ind_2010 <- c("AZ", "CA", "ID", "IA", "WA", "CO", "CT", "KS", "MN", "MS", "NV", "NM", "NY", "HI", "NJ", "KY", "ME", "MO", "OR", "TX")
repub_2000 <- c("FL", "IL", "KS", "MI", "NE", "OH", "PA", "UT", "VA")
dem_2000 <- c("AL", "CA", "GA", "IN", "MA", "MD", "NC", "WV")
ind_2000 <- c("AR", "AZ", "CO", "CT", "HI", "IA", "ID", "KY", "LA", "ME", "MN", "MO", "MS", "NH", "NJ", "NM", "NV", "NY", "OK", "OR", "RI", "SC", "TN", "TX", "WA", "WI")

who <- data.frame(year = integer(),
                         state = character(),
                         who = character())
for (i in seq(2002, 2010, 2)) {
  a <- data.frame(year = i,
                  state = repub_2000,
                  who = c("R"))
  b <- data.frame(year = i,
                  state = dem_2000,
                  who = c("D"))
  c <- data.frame(year = i,
                  state = ind_2000,
                  who = c("I"))
  who <- rbind(who, a, b, c)
}
who <- filter(who, !(state=="AZ" & year == 2008))

for (i in seq(2012, 2018, 2)) {
  a <- data.frame(year = i,
                  state = repub_2010,
                  who = c("R"))
  b <- data.frame(year = i,
                  state = dem_2010,
                  who = c("D"))
  c <- data.frame(year = i,
                  state = ind_2010,
                  who = c("I"))
  who <- rbind(who, a, b, c)
}
who$who <- as.factor(who$who)
```
### (1C) build density data.frame
```{r echo=FALSE}
#wget("https://www2.census.gov/programs-surveys/popest/datasets/2000-2009/counties/totals/co-est2009-alldata.csv")
#wget("https://www2.census.gov/programs-surveys/popest/datasets/2010-2019/counties/totals/co-est2019-alldata.csv")
#wget("https://www2.census.gov/prod2/statcomp/usac/excel/LND01.xls")
pop02_08 <- read.csv("co-est2009-alldata.csv")
pop10_18 <- read.csv("co-est2019-alldata.csv")
area <- readxl::read_excel("LND01.xls")

pop02_08 <- filter(pop02_08, STNAME != "District of Columbia")
pop10_18 <- filter(pop10_18, STNAME != "District of Columbia")
area <- filter(area, Areaname != c("UNITED STATES", "DISTRICT OF COLUMBIA", "District of Columbia"))

#create a STCOU column that matches the STCOU column in the area data.frame
#so I can eventually merge pop and area (to get density)
pop02_08$STCOU = 0
for (i in 1:nrow(pop02_08)) {
  pop02_08$STCOU[i] <- 1000 * pop02_08$STATE[i] + pop02_08$COUNTY[i]
}

pop10_18$STCOU = 0
for (i in 1:nrow(pop10_18)) {
  pop10_18$STCOU[i] <- 1000 * pop10_18$STATE[i] + pop10_18$COUNTY[i]
}

pop02_08 <- subset(
  pop02_08,
  select = c(
    STNAME,
    CTYNAME,
    STCOU,
    POPESTIMATE2002,
    POPESTIMATE2004,
    POPESTIMATE2006,
    POPESTIMATE2008
  )
)
pop10_18 <- subset(
  pop10_18,
  select = c(
    STNAME,
    CTYNAME,
    STCOU,
    POPESTIMATE2010,
    POPESTIMATE2012,
    POPESTIMATE2014,
    POPESTIMATE2016,
    POPESTIMATE2018
  )
)
area <- subset(
  area,
  select = c(
    Areaname,
    STCOU,
    LND010200D,
    LND110210D
  )
)
area <- area %>% rename(AREA_2000 = LND010200D, AREA_2010 = LND110210D)
area$STCOU <- as.numeric(area$STCOU)

#checking to see which counties don't match up
b <- unique(pop02_08$STCOU)
c <- unique(pop10_18$STCOU)
'%notin%' <- Negate("%in%")
dropped_from_02_08 <- pop02_08[which(b %notin% c),]
added_in_10_18 <- pop10_18[which(c %notin% b),]

pop10_18[pop10_18$STCOU==2195,]$CTYNAME <- "Petersburg Census Area"
pop02_08[pop02_08$STCOU==22059,]$CTYNAME <- "LaSalle Parish"
pop <- full_join(pop02_08, pop10_18, by=c("STNAME", "CTYNAME", "STCOU"))

d <- unique(pop$STCOU)
in_pop_butnot_02_08 <- pop[which(d %notin% b),]
in_pop_butnot_10_18 <- pop[which(d %notin% c),]


#checking to see which counties don't match up
a <- unique(area$STCOU)
p <- unique(pop$STCOU)
a_notin_p <- area[which(a %notin% p),]
p_notin_a <- pop[which(p %notin% a),]


dnsty <- left_join(pop, area, by="STCOU")

#need to figure out who aside from Kulsilvak is missing area...



#remove state totals
dnsty <- filter(dnsty, !dnsty$STNAME==dnsty$CTYNAME)
#merge dnsty and area by area:STCOU and dnsty:COUNTY (need to add 8000 to CA's ... etc.) 
dnsty$STCOU = 0
st <- 1000
for (i in 1:nrow(dnsty)) {
  while (dnsty$COUNTY[i] != 0) {
   dnsty$STCOU[i] <- st + dnsty$COUNTY  
  }
  st <- st + 1000
}

```

## (2) Impute vote values for uncontested elections.
### (2A) build uncontested and contested
```{r echo=FALSE}

#Initialize data.frames to collect data
uncontested <- data.frame(
  year = integer(),
  state = character(),
  district = integer(),
  candidate = character(),
  party = character(),
  candidatevotes = integer(),
  totalvotes = integer(),
  percent = numeric()
)

contested <- data.frame(
  year = integer(),
  state = character(),
  district = integer(),
  candidate = character(),
  party = character(),
  candidatevotes = integer(),
  totalvotes = integer(),
  percent = numeric()
)

YearlySummary <-
  data.frame(year = integer(),
             uncontested = integer(),
             competitive = integer())

#(A) For each year, for each state, for each district: collect up the districts where there was NOT both a Democrat and a Republican (uncontested), and the districts where there WAS both Dem & Repub (contested)

for (yr in seq(2002, 2018, 2)) {
  #count1 will count the number of uncontested races
  #count2 will count the number of competitive races
  count1 <- 0
  count2 <- 435
  for (st in state_abbrs$Code) {
    low <-
      min(rslts[rslts$year == yr & rslts$state == st,]$district)
    high <-
      max(rslts[rslts$year == yr & rslts$state == st,]$district)
    
    for (dst in seq(low, high)) {
      Dems <- (rslts[rslts$year == yr & rslts$state == st &
                       rslts$district == dst,]$party == "democrat")
      Repubs <- (rslts[rslts$year == yr & rslts$state == st &
                         rslts$district == dst,]$party == "republican")
      blowout <- (rslts[rslts$year == yr & rslts$state == st &
                          rslts$district == dst,]$percent > 55)
      if (sum(blowout, na.rm = TRUE) == 1) {
        count2 <- count2 - 1
      }
      
      if (sum(Dems, na.rm = TRUE) == 0 |
          sum(Repubs, na.rm = TRUE) == 0) {
        new <- rslts[rslts$year == yr & rslts$state == st &
                       rslts$district == dst,]
        count1 <- count1 + 1
        uncontested <- rbind(uncontested, new)
      } else {
        new <- rslts[rslts$year == yr & rslts$state == st &
                       rslts$district == dst,]
        contested <- rbind(contested, new)
      }
    }
  }
  
  new <-
    data.frame(year = yr,
               uncontested = count1,
               competitive = count2)
  YearlySummary <- rbind(YearlySummary, new)
}
```
### (2B) build YearlyVoteTotals and YearlyNoContesteds
```{r echo=FALSE}

#Initialize data.frames to collect data
YearlyVoteTotals <-
  data.frame(
    year = integer(),
    state = character(),
    party = character(),
    max = integer(),
    min = integer(),
    mean = integer(),
    adjusted_sum = integer(),
    adjusted_percent = numeric()
  )

YearlyNoContesteds <-
  data.frame(
    year = integer(),
    state = character(),
    num_districts = integer()
  )

#(B) Going year by year, state by state, find max and min votes for each party and store in a data.frame (which will be used to impute missing values)

for (yr in seq(2002, 2018, 2)) {
  for (st in state_abbrs$Code) {
    low <-
      min(rslts[rslts$year == yr & rslts$state == st,]$district)
    high <-
      max(rslts[rslts$year == yr & rslts$state == st,]$district)
    demvotes <- c()
    repubvotes <- c()
    
    #Just looking for max and min in the contested elections
    ContestedDistricts <- unique(contested[contested$year == yr &
                                             contested$state == st, ]$district)
    for (dst in ContestedDistricts) {
      demvotes <-
        append(demvotes, contested[contested$year == yr &
                                     contested$state == st &
                                     contested$district == dst &
                                     contested$party == "democrat", ]$candidatevotes)
      repubvotes <-
        append(repubvotes, contested[contested$year == yr &
                                       contested$state == st &
                                       contested$district == dst &
                                       contested$party == "republican", ]$candidatevotes)
    }
    if (length(ContestedDistricts)==0) {
      Districts <- unique(rslts[rslts$year == yr &
                                             rslts$state == st, ]$district)
      TotalDistricts <- max(Districts)-min(Districts)+1
      new <-
        data.frame(year = yr,
                   state = st,
                   num_districts = TotalDistricts
                   )
      YearlyNoContesteds <- rbind(YearlyNoContesteds, new)
      
    } else {
      newDem <-
        data.frame(
          year = yr,
          state = st,
          party = "democrat",
          max = max(demvotes),
          min = min(demvotes),
          adjusted_sum = 0,
          adjusted_percent = 0
        )
      newRepub <-
        data.frame(
          year = yr,
          state = st,
          party = "republican",
          max = max(repubvotes),
          min = min(repubvotes),
          adjusted_sum = 0,
          adjusted_percent = 0
        )
      YearlyVoteTotals <- rbind(YearlyVoteTotals, newDem, newRepub)
    }
  }
}
```
### (2C) build imputed
```{r echo=FALSE}

#NOTE: As the YearlyNoContesteds data.frame shows, there were two times where the whole states delegation was uncontested (1994 in "LA" and 2008 in "AR").  Since there is no data to impute from for each of these instances, I've removed them from both the "rslts" data.frame and the "uncontested" data.frame.
rslts <- filter(rslts, !(rslts$year == 1994 & rslts$state == "LA"))
rslts <- filter(rslts, !(rslts$year == 2008 & rslts$state == "AR"))
uncontested <- filter(uncontested, !(uncontested$year == 1994 & uncontested$state == "LA"))
uncontested <- filter(uncontested, !(uncontested$year == 2008 & uncontested$state == "AR"))

state_abbrs <- filter(state_abbrs, !Code %in% c("WY", "VT", "SD", "ND", "MT", "DE", "AK","DC"))
#Initialize data.frames to collect data
imputed <- data.frame(
  year = integer(),
  state = character(),
  district = integer(),
  candidate = character(),
  party = character(),
  candidatevotes = integer(),
  totalvotes = integer(),
  percent = numeric()
)

#(C) Create a data.frame of imputed "candidates" with their vote "totals" (minimum # of votes that party got in a district in that state for that election cycle)  And while doing this, replace rslts$candidatevotes with the imputed vote "total" for the uncontested candidate (maximum # of votes that party got in a district for that election cycle).

for (i in (1:nrow(uncontested))) {
  yr <- uncontested$year[i]
  st <- uncontested$state[i]
  dst <- uncontested$district[i]
  if (uncontested$party[i] == "democrat") {
    new_party <- "republican"
    new_votes_loser <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "republican",]$min)
    new_votes_winner <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "republican",]$max)
  } else {
    new_party <-  "democrat"
    new_votes_loser <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "democrat",]$min)
    new_votes_winner <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "democrat",]$max)
  }
  new_votes_total <- new_votes_loser + new_votes_winner
  
  new <- data.frame(
    year = uncontested$year[i],
    state = uncontested$state[i],
    district = uncontested$district[i],
    candidate = "imputed",
    party = new_party,
    candidatevotes = new_votes_loser,
    totalvotes = new_votes_total,
    percent = round(100 * new_votes_loser / new_votes_total, 2)
  )
  
  imputed <- rbind(imputed, new)
  
  #replace the votes and vote total for the uncontested candidate
  rw <-
    which(uncontested$year == yr &
            uncontested$state == st & uncontested$district == dst)
  uncontested$candidatevotes[rw] <- new_votes_winner
  uncontested$totalvotes[rw] <- new_votes_total
  uncontested$percent[rw] <-
    round(100 * new_votes_winner / new_votes_total, 2)
  
}

```
### (2D) put it all together into Results and DemYearlyResults & RepubYearlyResults
```{r warning=FALSE, echo=FALSE}
Results <- rbind(contested, uncontested, imputed)
Results$winner <- c("?")

#by year by state get the winner for each district
for (yr in seq(2002, 2018, 2)) {
  for (st in state_abbrs$Code) {
    if ((st == "LA" & yr == 1994) | (st == "AR" & yr == 2008)) {
      #skip the dst loop for the two years/states when there were no contested elections
    } else {
      Districts <- unique(Results[Results$year == yr &
                                    Results$state == st, ]$district)
      for (dst in (min(Districts):max(Districts))) {
        if (Results[Results$year == yr &
                    Results$state == st &
                    Results$district == dst &
                    Results$party == "democrat",]$candidatevotes >
            Results[Results$year == yr &
                    Results$state == st &
                    Results$district == dst &
                    Results$party == "republican",]$candidatevotes) {
          Results[Results$year == yr &
                    Results$state == st &
                    Results$district == dst &
                    Results$party == "democrat",]$winner <- "won"
          Results[Results$year == yr &
                    Results$state == st &
                    Results$district == dst &
                    Results$party == "republican",]$winner <-
            "lost"
        } else {
          Results[Results$year == yr &
                    Results$state == st &
                    Results$district == dst &
                    Results$party == "republican",]$winner <- "won"
          Results[Results$year == yr &
                    Results$state == st &
                    Results$district == dst &
                    Results$party == "democrat",]$winner <- "lost"
        }
      }
    }
  }
}

#calculate the total votes and total seats
YearlyResults <- Results %>%
  group_by(year, state, party) %>%
  summarise(votes = sum(candidatevotes))
YearlyResults <- ungroup(YearlyResults)

YearlyResults$vote_percentage <- seq(0, 1, nrow(YearlyResults))
YearlyResults$seats <- seq(0, 1, nrow(YearlyResults))
YearlyResults$seat_percentage <- seq(0, 1, nrow(YearlyResults))

for (yr in seq(2002, 2018, 2)) {
  for (st in state_abbrs$Code) {
    demvotes <- YearlyResults[YearlyResults$year == yr &
                                YearlyResults$state == st &
                                YearlyResults$party == "democrat", ]$votes
    
    repubvotes <- YearlyResults[YearlyResults$year == yr &
                                  YearlyResults$state == st &
                                  YearlyResults$party == "republican", ]$votes
    
    totalvotes <- demvotes + repubvotes
    
    YearlyResults[YearlyResults$year == yr &
                    YearlyResults$state == st &
                    YearlyResults$party == "democrat",]$vote_percentage <-
      round(100 * demvotes / totalvotes, 2)
    YearlyResults[YearlyResults$year == yr &
                    YearlyResults$state == st &
                    YearlyResults$party == "republican",]$vote_percentage <-
      round(100 * repubvotes / totalvotes, 2)
    
    demseats <-
      nrow(Results[Results$year == yr &
                     Results$state == st &
                     Results$party == "democrat" &
                     Results$winner == "won",])
    repubseats <-
      nrow(Results[Results$year == yr &
                     Results$state == st &
                     Results$party == "republican" &
                     Results$winner == "won",])
    totalseats <- demseats + repubseats
    
    YearlyResults[YearlyResults$year == yr &
                    YearlyResults$state == st &
                    YearlyResults$party == "democrat",]$seat_percentage <-
      round(100 * demseats / totalseats, 2)
    YearlyResults[YearlyResults$year == yr &
                    YearlyResults$state == st &
                    YearlyResults$party == "republican",]$seat_percentage <-
      round(100 * repubseats / totalseats, 2)
    YearlyResults[YearlyResults$year == yr &
                    YearlyResults$state == st,]$seats <-
      totalseats
  }
}

DemYearlyResults <- filter(YearlyResults, party=="democrat")
DemYearlyResults <- DemYearlyResults %>% inner_join(who, by = c("year", "state"))
RepubYearlyResults <- filter(YearlyResults, party=="republican")
RepubYearlyResults <- RepubYearlyResults %>% inner_join(who, by = c("year", "state"))
```

## (3) EDA 
### (3A)vote_percentage vs seat_percentage
```{r echo=FALSE}


ggplot(DemYearlyResults[DemYearlyResults$who==c("D", "R"), ]) +
  aes(x = vote_percentage, y = seat_percentage, color = who) +
  scale_color_manual(values = c("blue", "red")) +
  geom_point(aes(size = seats, color=who),
             alpha = 0.5) +
  labs(x = "% of votes that were Democratic", y = "% of seats that are Democratic", title = "Proportional Representation?", subtitle = "Democratic vs. Rebulican controlled redistricting on Democratic results", col = "who redistricted", size = "number of seats") +
  geom_abline(slope = 1,
              intercept = 0,
              color = "grey") +
  xlim(20, 80) +
  theme_bw()

ggplot(RepubYearlyResults[RepubYearlyResults$who==c("D", "R"), ]) +
  aes(x = vote_percentage, y = seat_percentage, color = who) +
  scale_color_manual(values = c("blue", "red")) +
  geom_point(aes(size = seats, color=who),
             alpha = 0.5) +
  labs(x = "% of votes that were Republican", y = "% of seats that are Republican", title = "Proportional Representation?", subtitle = "Democratic vs. Rebulican controlled redistricting on Republican results", col = "who redistricted", size = "number of seats") +
  geom_abline(slope = 1,
              intercept = 0,
              color = "grey") +
  xlim(20, 80) +
  theme_bw()

ggplot(DemYearlyResults) +
  aes(x = vote_percentage, y = seat_percentage, color = who) +
  scale_color_manual(values = c("blue", "green", "red")) +
  geom_point(aes(size = seats, color=who),
             alpha = 0.5) +
  labs(x = "% of votes that were Democratic", y = "% of seats that are Democratic", title = "Proportional Representation?", subtitle = "Democratic vs. Rebulican vs. Independent controlled redistricting on Democratic results", col = "who redistricted", size = "number of seats") +
  geom_abline(slope = 1,
              intercept = 0,
              color = "grey") +
  geom_smooth(method=lm, se=FALSE) +
  xlim(0, 80) +
  theme_bw()

```
### (3B) density vs seat_percentage:vote_percentage

## (4) Model fitting
### An example data.frame to think through my model fitting
```{r echo=FALSE}
States <- read_csv("States.csv")

edf12 <- data.frame(year = rep("2012", nrow(States)),
                  state = States,
                  clumping = round(abs(rnorm(nrow(States), 150, 200)), 1),
                  group = rep(factor(c("Dem", "Rep", "Ind", "Split")), length.out=nrow(States)),
                  votes = round(60 + rnorm(nrow(States), 0, 10), 1),
                  seats = round(runif(nrow(States), 0, 100),1))
edf14 <- data.frame(year = rep("2014", nrow(States)),
                  state = States,
                  clumping = round(abs(rnorm(nrow(States), 150, 200)), 1),
                  group = rep(factor(c("Dem", "Rep", "Ind", "Split")), length.out=nrow(States)),
                  votes = round(60 + rnorm(nrow(States), 0, 10), 1),
                  seats = round(runif(nrow(States), 0, 100),1))
edf <- rbind(edf12, edf14)

ggplot(data=edf) +
  geom_point(aes(x=votes, y=seats, color=group)) +
  geom_smooth(method=lm, aes(x=votes, y=seats, color=group), se=FALSE)


fit <- lmer(seats ~ votes + (1+votes|group), data=edf)
 #unable to evaluate scaled gradientModel failed to converge: degenerate  Hessian with 1 negative eigenvalues

 fit <- lmer(seats ~ (1|group), data=edf)
 coef(fit)
 confint(fit)

 fit <- stan_lmer(seats ~ clumping + votes + (1+votes|group), control = list(adapt_delta = 0.99), data = edf)
 summary(fit)
 coef(fit)
 posterior_interval(fit)

 pairs(fit)
```
### fitting to DemYearlyResults
```{r echo=FALSE}
fit <- lmer(seat_percentage ~ vote_percentage + (1+vote_percentage|who), data=DemYearlyResults)
#with edf: unable to evaluate scaled gradientModel failed to converge: degenerate  Hessian with 1 negative eigenvalues

fit <- lmer(seat_percentage ~ (1|who), data=DemYearlyResults)
coef(fit)
confint(fit)

fit <- lmer(seat_percentage ~ (vote_percentage|who), data=DemYearlyResults)
coef(fit)

fit <- stan_lmer(seat_percentage ~ vote_percentage + (1+vote_percentage|who), control = list(adapt_delta = 0.99), data = DemYearlyResults)
summary(fit)
coef(fit)
posterior_interval(fit)

pairs(fit)
```
# RESULTS

# DISCUSSION

# BIBLIOGRAPHY and APPENDIX
## Citations 
(need to figure out how to use LaTex to display this citation)
@incollection{DVN/IG0UN2/ELBYL3_2017,
author = {MIT Election Data and Science Lab},
publisher = {Harvard Dataverse},
title = {1976-2018-house2.tab},
booktitle = {U.S. House 1976â€“2018},
UNF = {UNF:6:8iuXTceVO5a7EpOwUD5UPw==},
year = {2017},
version = {V7},
doi = {10.7910/DVN/IG0UN2/ELBYL3},
url = {https://doi.org/10.7910/DVN/IG0UN2/ELBYL3}
}

https://www.census.gov/library/publications/2011/compendia/usa-counties-2011.html#POP

to get .xls for population and .xls for area:

https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjHkPmp4bftAhV5FlkFHbDHBvwQFjAAegQIAxAC&url=https%3A%2F%2Fwww2.census.gov%2Flibrary%2Fpublications%2F2011%2Fcompendia%2Fusa-counties%2Fexcel%2FMastdata.xls&usg=AOvVaw1ahgb3GWupqOb1UHYbZlMw


Copyright
Copyright 2020 Bruce C. Mallory

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.