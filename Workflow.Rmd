---
title: "Workflow"
author: "Bruce Mallory"
date: "12/2/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load("HelpersMG", "readr", "ggplot2", "lmer4", "rstanarm", "dplyr", "stringr", "e1071")
```

# (1) Load and clean election data
## build rslts
#wget("https://dataverse.harvard.edu/api/access/datafile/:persistentId?persistentId=doi:10.7910/DVN/IG0UN2/ELBYL3")
```{r echo=FALSE, warning=FALSE, message=FALSE}
rslts <- read.table("ELBYL3", header = TRUE)

# Historical note.  In the data file, there was a column "special."  There were two sets of elections where special="TRUE."  Both is Texas.  One in 1996, the other 2006.  In the first the US District Court found that the redrawn districts were unconstitutional and ordered a special election to redo the primary election - then held a general election in December.  And again in 2006, the US Supreme Court found that numerous redrawn districts were unconstitutional and again ordered a new district map and a special election for the primaries with a December general election.  Since these special elections were "redoing" the primary elections in those districts, I've removed them from the data set, thus keeping only the general elections in the data set.  These were the only cases in the data file where there where special elections
rslts <- filter(rslts, special = TRUE)

# From the data set, I've kept seven columns for my analysis and filtered out for years 1992 and beyond
rslts <-
  subset(
    rslts,
    select = c(
      year,
      state_po,
      district,
      candidate,
      party,
      candidatevotes,
      totalvotes
    )
  )
rslts <- rslts %>%  rename(state = state_po)
rslts <- filter(rslts, year >= 1992)
rslts$percent <- round(100 * rslts$candidatevotes / rslts$totalvotes, 2)

# NOTE: in Minnesota, the democratic party is called "democratic-farmer-labor," so I've changed it's name in the data.frame to "democrat."  And same for the republican party "independent-republican"
rslts$party[rslts$party == "democratic-farmer-labor"] <- "democrat"
rslts$party[rslts$party == "independent-republican"] <- "republican"

# In preparation for collecting the uncontested elections, I checked to see whether or not I should include the "libertarian" party.  They ran candidates in 2,018 elections between 1990 and 2018.  But never got higher than 31% of the vote and their mean vote percentage was 3.4% (with a distribution of results that was heavily skewed right with "skewness" = 3.4).  As such I have not included the "libertarian" party as a major party, and have confined my analysis to Democrats and Republicans.
libs <- filter(rslts, party == "libertarian")
num_libertarian_canditates <- nrow(libs)
high_percent_libertarians <- max(libs$percent)
mean_percent_libertarians <- mean(libs$percent)
skew_percent_libertarians <- skewness(libs$percent)

# Remove all states that only have one representative to congress - in these states there is never a need for redistricting (WY, VT, SD, ND, MT, DE, AK)
rslts <- filter(rslts, !state %in% c("WY", "VT", "SD", "ND", "MT", "DE", "AK"))

# Include candidates who are either republican or democrat
rslts <- filter(rslts, party == "democrat" | party == "republican")

state_abbrs <- read.csv("states.csv")
state_abbrs <- filter(state_abbrs, !Code %in% c("WY", "VT", "SD", "ND", "MT", "DE", "AK","DC"))
```

## (2) Impute vote values for uncontested elections.
## (A) build uncontested and contested
```{r}

#Initialize data.frames to collect data
uncontested <- data.frame(
  year = integer(),
  state = character(),
  district = integer(),
  candidate = character(),
  party = character(),
  candidatevotes = integer(),
  totalvotes = integer(),
  percent = numeric()
)

contested <- data.frame(
  year = integer(),
  state = character(),
  district = integer(),
  candidate = character(),
  party = character(),
  candidatevotes = integer(),
  totalvotes = integer(),
  percent = numeric()
)

YearlySummary <-
  data.frame(year = integer(),
             uncontested = integer(),
             competitive = integer())

#(A) For each year, for each state, for each district: collect up the districts where there was NOT both a Democrat and a Republican (uncontested), and the districts where there WAS both Dem & Repub (contested)

for (yr in seq(1992, 2018, 2)) {
  #count1 will count the number of uncontested races
  #count2 will count the number of competitive races
  count1 <- 0
  count2 <- 435
  for (st in state_abbrs$Code) {
    low <-
      min(rslts[rslts$year == yr & rslts$state == st,]$district)
    high <-
      max(rslts[rslts$year == yr & rslts$state == st,]$district)
    
    for (dst in seq(low, high)) {
      Dems <- (rslts[rslts$year == yr & rslts$state == st &
                       rslts$district == dst,]$party == "democrat")
      Repubs <- (rslts[rslts$year == yr & rslts$state == st &
                         rslts$district == dst,]$party == "republican")
      blowout <- (rslts[rslts$year == yr & rslts$state == st &
                          rslts$district == dst,]$percent > 55)
      if (sum(blowout, na.rm = TRUE) == 1) {
        count2 <- count2 - 1
      }
      
      if (sum(Dems, na.rm = TRUE) == 0 |
          sum(Repubs, na.rm = TRUE) == 0) {
        new <- rslts[rslts$year == yr & rslts$state == st &
                       rslts$district == dst,]
        count1 <- count1 + 1
        uncontested <- rbind(uncontested, new)
      } else {
        new <- rslts[rslts$year == yr & rslts$state == st &
                       rslts$district == dst,]
        contested <- rbind(contested, new)
      }
    }
  }
  
  new <-
    data.frame(year = yr,
               uncontested = count1,
               competitive = count2)
  YearlySummary <- rbind(YearlySummary, new)
}
```
## (B) Build YearlyVoteTotals and YearlyNoContesteds
```{r}

#Initialize data.frames to collect data
YearlyVoteTotals <-
  data.frame(
    year = integer(),
    state = character(),
    party = character(),
    max = integer(),
    min = integer(),
    mean = integer(),
    adjusted_sum = integer(),
    adjusted_percent = numeric()
  )

YearlyNoContesteds <-
  data.frame(
    year = integer(),
    state = character(),
    num_districts = integer()
  )

#(B) Going year by year, state by state, find max and min votes for each party and store in a data.frame (which will be used to impute missing values)

for (yr in seq(1992, 2018, 2)) {
  for (st in state_abbrs$Code) {
    low <-
      min(rslts[rslts$year == yr & rslts$state == st,]$district)
    high <-
      max(rslts[rslts$year == yr & rslts$state == st,]$district)
    demvotes <- c()
    repubvotes <- c()
    
    #Just looking for max and min in the contested elections
    ContestedDistricts <- unique(contested[contested$year == yr &
                                             contested$state == st, ]$district)
    for (dst in ContestedDistricts) {
      demvotes <-
        append(demvotes, contested[contested$year == yr &
                                     contested$state == st &
                                     contested$district == dst &
                                     contested$party == "democrat", ]$candidatevotes)
      repubvotes <-
        append(repubvotes, contested[contested$year == yr &
                                       contested$state == st &
                                       contested$district == dst &
                                       contested$party == "republican", ]$candidatevotes)
    }
    if (length(ContestedDistricts)==0) {
      Districts <- unique(rslts[rslts$year == yr &
                                             rslts$state == st, ]$district)
      TotalDistricts <- max(Districts)-min(Districts)+1
      new <-
        data.frame(year = yr,
                   state = st,
                   num_districts = TotalDistricts
                   )
      YearlyNoContesteds <- rbind(YearlyNoContesteds, new)
      
    } else {
      newDem <-
        data.frame(
          year = yr,
          state = st,
          party = "democrat",
          max = max(demvotes),
          min = min(demvotes),
          adjusted_sum = 0,
          adjusted_percent = 0
        )
      newRepub <-
        data.frame(
          year = yr,
          state = st,
          party = "republican",
          max = max(repubvotes),
          min = min(repubvotes),
          adjusted_sum = 0,
          adjusted_percent = 0
        )
      YearlyVoteTotals <- rbind(YearlyVoteTotals, newDem, newRepub)
    }
  }
}
```
## (C) build imputed
```{r}

#NOTE: As the YearlyNoContesteds data.frame shows, there were two times where the whole states delegation was uncontested (1994 in "LA" and 2008 in "AR").  Since there is no data to impute from for each of these instances, I've removed them from both the "rslts" data.frame and the "uncontested" data.frame.
rslts <- filter(rslts, !(rslts$year == 1994 & rslts$state == "LA"))
rslts <- filter(rslts, !(rslts$year == 2008 & rslts$state == "AR"))
uncontested <- filter(uncontested, !(uncontested$year == 1994 & uncontested$state == "LA"))
uncontested <- filter(uncontested, !(uncontested$year == 2008 & uncontested$state == "AR"))

state_abbrs <- filter(state_abbrs, !Code %in% c("WY", "VT", "SD", "ND", "MT", "DE", "AK","DC"))
#Initialize data.frames to collect data
imputed <- data.frame(
  year = integer(),
  state = character(),
  district = integer(),
  candidate = character(),
  party = character(),
  candidatevotes = integer(),
  totalvotes = integer(),
  percent = numeric()
)

#(C) Create a data.frame of imputed "candidates" with their vote "totals" (minimum # of votes that party got in a district in that state for that election cycle)  And while doing this, replace rslts$candidatevotes with the imputed vote "total" for the uncontested candidate (maximum # of votes that party got in a district for that election cycle).

for (i in (1:nrow(uncontested))) {
  yr <- uncontested$year[i]
  st <- uncontested$state[i]
  dst <- uncontested$district[i]
  if (uncontested$party[i] == "democrat") {
    new_party <- "republican"
    new_votes_loser <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "republican",]$min)
    new_votes_winner <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "republican",]$max)
  } else {
    new_party <-  "democrat"
    new_votes_loser <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "democrat",]$min)
    new_votes_winner <-
      (YearlyVoteTotals[YearlyVoteTotals$year == yr &
                          YearlyVoteTotals$state == st &
                          YearlyVoteTotals$party == "democrat",]$max)
  }
  new_votes_total <- new_votes_loser + new_votes_winner
  
  new <- data.frame(
    year = uncontested$year[i],
    state = uncontested$state[i],
    district = uncontested$district[i],
    candidate = "imputed",
    party = new_party,
    candidatevotes = new_votes_loser,
    totalvotes = new_votes_total,
    percent = round(100 * new_votes_loser / new_votes_total, 2)
  )
  
  imputed <- rbind(imputed, new)
  
  #replace the votes and vote total for the uncontested candidate
  rw <-
    which(uncontested$year == yr &
            uncontested$state == st & uncontested$district == dst)
  uncontested$candidatevotes[rw] <- new_votes_winner
  uncontested$totalvotes[rw] <- new_votes_total
  uncontested$percent[rw] <-
    round(100 * new_votes_winner / new_votes_total, 2)
  
}

```
## (D) put it all together in to Results
```{r}
Results <- rbind(contested, uncontested, imputed)
```


https://www.census.gov/library/publications/2011/compendia/usa-counties-2011.html#POP
# to get .xls for population and .xls for area
https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjHkPmp4bftAhV5FlkFHbDHBvwQFjAAegQIAxAC&url=https%3A%2F%2Fwww2.census.gov%2Flibrary%2Fpublications%2F2011%2Fcompendia%2Fusa-counties%2Fexcel%2FMastdata.xls&usg=AOvVaw1ahgb3GWupqOb1UHYbZlMw
# to get the code explanations for the above



```

## (2) An example data.frame to think through my analysis
```{r}
States <- read_csv("States.csv")

edf12 <- data.frame(year = rep("2012", nrow(States)),
                  state = States,
                  clumping = round(abs(rnorm(nrow(States), 150, 200)), 1),
                  group = rep(factor(c("Dem", "Rep", "Ind", "Split")), length.out=nrow(States)),
                  votes = round(60 + rnorm(nrow(States), 0, 10), 1),
                  seats = round(runif(nrow(States), 0, 100),1))
edf14 <- data.frame(year = rep("2014", nrow(States)),
                  state = States,
                  clumping = round(abs(rnorm(nrow(States), 150, 200)), 1),
                  group = rep(factor(c("Dem", "Rep", "Ind", "Split")), length.out=nrow(States)),
                  votes = round(60 + rnorm(nrow(States), 0, 10), 1),
                  seats = round(runif(nrow(States), 0, 100),1))
edf <- rbind(edf12, edf14)

ggplot(data=edf) +
  geom_point(aes(x=votes, y=seats, color=group)) +
  geom_smooth(method=lm, aes(x=votes, y=seats, color=group), se=FALSE)

```
## fitting
```{r}
fit <- lmer(seats ~ votes + (1+votes|group), data=edf)
#unable to evaluate scaled gradientModel failed to converge: degenerate  Hessian with 1 negative eigenvalues

fit <- lmer(seats ~ (1|group), data=edf)
coef(fit)
confint(fit)

fit <- stan_lmer(seats ~ clumping + votes + (1+votes|group), control = list(adapt_delta = 0.99), data = edf)
summary(fit)
coef(fit)
posterior_interval(fit)

pairs(fit)
```
## Citations 
#These two are for the Harvard dataverse files (need to figure out how to use LaTex to diplay the second one)
<?xml version='1.0' encoding='UTF-8'?><xml><records><record><ref-type name="Dataset">59</ref-type><contributors><authors><author>MIT Election Data and Science Lab</author></authors><secondary-authors><author>MIT Election Data and Science Lab</author></secondary-authors></contributors><titles><title>U.S. House 1976–2018</title></titles><section>2017-11-01</section><dates><year>2017</year></dates><edition>DRAFT VERSION</edition><keywords><keyword>Elections</keyword></keywords><language>English</language><publisher>Harvard Dataverse</publisher><urls><related-urls><url>https://doi.org/10.7910/DVN/IG0UN2</url></related-urls></urls><electronic-resource-num>doi/10.7910/DVN/IG0UN2</electronic-resource-num></record></records></xml>

@incollection{DVN/IG0UN2/ELBYL3_2017,
author = {MIT Election Data and Science Lab},
publisher = {Harvard Dataverse},
title = {1976-2018-house2.tab},
booktitle = {U.S. House 1976–2018},
UNF = {UNF:6:8iuXTceVO5a7EpOwUD5UPw==},
year = {2017},
version = {V7},
doi = {10.7910/DVN/IG0UN2/ELBYL3},
url = {https://doi.org/10.7910/DVN/IG0UN2/ELBYL3}
}

## Copyright
Copyright 2020 Bruce C. Mallory

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.